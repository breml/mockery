{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"mockery","text":"<p>Alpha Test</p> <p>Mockery <code>v3</code> is currently in alpha and should not be used for production.</p> <p>Mockery is a project that creates mock implementations of Golang interfaces. It inspects source code and generates implementations of the interface that aid in testing.</p> <p>In addition to providing a number of different styles of mocks, mockery also allows users to provide their own template files that will then be rendered using a set of template data, methods, and functions that provide comprehensive typing information about the Go interface in question.</p> <p> </p>"},{"location":"#why-mockery","title":"Why mockery?","text":"<p>When you have an interface like this:</p> db.go<pre><code>type DB interface {\n    Get(val string) string\n}\n</code></pre> <p>and a function that takes this interface:</p> db_getter.go<pre><code>func getFromDB(db DB) string {\n    return db.Get(\"ice cream\")\n}\n</code></pre> <p>We can use simple configuration to generate a mock implementation for the interface:</p> .mockery.yaml<pre><code>with-expecter: True\npackages:\n    github.com/org/repo:\n        interfaces:\n            DB:\n</code></pre> Bash<pre><code>$ mockery\n05 Mar 23 21:49 CST INF Starting mockery dry-run=false version=v3.0.0\n05 Mar 23 21:49 CST INF Using config: .mockery.yaml dry-run=false version=v3.0.0\n05 Mar 23 21:49 CST INF Generating mock dry-run=false interface=DB qualified-name=github.com/org/repo version=v3.0.0\n</code></pre> <p>We can then use the mock object in a test:</p> db_getter_test.go<pre><code>import (\n    \"testing\"\n\n    \"github.com/stretchr/testify/assert\"\n)\n\nfunc Test_getFromDB(t *testing.T) {\n    mockDB := NewMockDB(t)\n    mockDB.EXPECT().Get(\"ice cream\").Return(\"chocolate\").Once()\n    flavor := getFromDB(mockDB)\n    assert.Equal(t, \"chocolate\", flavor)\n}\n</code></pre>"},{"location":"#why-use-mockery","title":"Why use mockery?","text":"<ol> <li>You gain access to a number of pre-curated mock implementations that can be used in testing. This includes traditional \"mockery-style\" mocks, as well as other styles from the open source community such as from https://github.com/matryer/moq. Such mocks allow you to quickly define how the implementation should behave under test without having to manually curate your own mocks/stubs/fakes.</li> <li>Mockery benefits from a large number of performance improvements that almost all other Go code-generation projects currently have not employed. This means that it's orders of magnitude faster for large codebases.</li> <li>Mockery provides a comprehensive, centralized, flexible, and simple configuration scheme driven off of yaml instead of relying on sprawling <code>//go:generate</code> commands.</li> <li>Mockery is a code-generation framework. While its original goal is to provide mock implementations for testing purposes, users can supply their own templates to auto-generate any kind of code that needs to be based off of interfaces.</li> <li>A number of high profile companies, projects, and communities trust Mockery.</li> </ol>"},{"location":"#who-uses-mockery","title":"Who uses mockery?","text":"<ul> <li> Grafana </li> <li> Google Skia </li> <li> Google Skyzkaller </li> <li> Hashicorp </li> <li> Uber Cadence </li> <li> Jaegertracing </li> <li> Splunk kafka-mq-go </li> <li> </li> <li> </li> <li> </li> <li></li> <li> eksctl </li> <li> </li> <li> Task <li> <p>Get Started</p>"},{"location":"changelog/","title":"Changelog","text":"<p>This changelog describes major feature additions. Please view the <code>releases</code> page for more details on commits and minor changes.</p>"},{"location":"changelog/#v2290-template-functions","title":"<code>v2.29.0</code> template functions","text":"<p>This release adds a large number of template functions available for use in the <code>packages</code> templating engine.</p>"},{"location":"changelog/#v2250-recursive-config","title":"<code>v2.25.0</code> <code>recursive</code> config","text":"<p>The <code>recursive</code> parameter allows mockery to dynamically discover sub-packages when using the <code>packages</code> config.</p>"},{"location":"changelog/#v2240-exclude-config","title":"<code>v2.24.0</code> <code>exclude</code> config","text":"<p>The <code>exclude</code> parameter allows you to define subpaths to ignore. This is currently only compatible when using non-<code>packages</code> config.</p>"},{"location":"changelog/#v2230-replace-types","title":"<code>v2.23.0</code> Replace Types","text":"<p>The <code>replace-type</code> parameter allows adding a list of type replacements to be made in package and/or type names. This can help overcome issues like usage of type aliases that point to internal packages.</p>"},{"location":"changelog/#v2210-packages-configuration","title":"<code>v2.21.0</code>: <code>packages</code> configuration","text":"<p>In this version we release the <code>packages</code> configuration section. This new parameter allows defining specific packages to generate mocks for, while also giving fine-grained control over which interfaces are mocked, where they are located, and how they are configured. Details are provided here.</p> <p>Community input is desired before we consider deprecations of dynamic walking (via <code>all: True</code>): https://github.com/vektra/mockery/discussions/549</p>"},{"location":"changelog/#v2200-improved-return-value-functions","title":"<code>v2.20.0</code>: Improved Return Value Functions","text":"<p>Return value functions that return an entire method's return value signature can now be provided.</p> Go<pre><code>proxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\nReturn(\n    func(ctx context.Context, s string) (string, error) {\n        return s, nil\n    }\n)\n</code></pre> <p>You may still use the old way where one function is provided for each return value:</p> Go<pre><code>proxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\nReturn(\n    func(ctx context.Context, s string) string {\n        return s\n    },\n    func(ctx context.Context, s string) error {\n        return nil\n    },\n)\n</code></pre>"},{"location":"changelog/#2190-inpackage-suffix-option","title":"<code>2.19.0</code>: <code>inpackage-suffix</code> option","text":"<p>When <code>inpackage-suffix</code> is set to <code>True</code>, mock files are suffixed with <code>_mock</code> instead of being prefixed with <code>mock_</code> for InPackage mocks</p>"},{"location":"changelog/#v2160-config-search-path","title":"<code>v2.16.0</code>: Config Search Path","text":"<p>Mockery will iteratively search every directory from the current working directory up to the root path for a <code>.mockery.yaml</code> file, if one is not explicitly provided.</p>"},{"location":"changelog/#v2130-generics-support","title":"<code>v2.13.0</code>: Generics support","text":"<p>Mocks are now capable of supporting Golang generics.</p>"},{"location":"changelog/#v2110-mock-constructors","title":"<code>v2.11.0</code>: Mock constructors","text":"<p>Mockery v2.11 introduces constructors for all mocks. This makes instantiation and mock registration a bit easier and less error-prone (you won't have to worry about forgetting the <code>AssertExpectations</code> method call anymore).</p> <p>Before v2.11: Go<pre><code>factory := &amp;mocks.Factory{}\nfactory.Test(t) // so that mock does not panic when a method is unexpected\ndefer factory.AssertExpectations(t)\n</code></pre></p> <p>After v2.11: Go<pre><code>factory := mocks.NewFactory(t)\n</code></pre></p> <p>The constructor sets up common functionalities automatically - The <code>AssertExpectations</code> method is registered to be called at the end of the tests via <code>t.Cleanup()</code> method. - The testing.TB interface is registered on the <code>mock.Mock</code> so that tests don't panic when a call on the mock is unexpected.</p>"},{"location":"changelog/#v2100-expecter-structs","title":"<code>v2.10.0</code>: Expecter Structs","text":"<p>Mockery now supports an \"expecter\" struct, which allows your tests to use type-safe methods to generate call expectations. When enabled through the <code>with-expecter: True</code> mockery configuration, you can enter into the expecter interface by simply calling <code>.EXPECT()</code> on your mock object.</p> <p>For example, given an interface such as Go<pre><code>type Requester interface {\n    Get(path string) (string, error)\n}\n</code></pre></p> <p>You can use the type-safe expecter interface as such: Go<pre><code>requesterMock := mocks.NewRequester(t)\nrequesterMock.EXPECT().Get(\"some path\").Return(\"result\", nil)\nrequesterMock.EXPECT().\n    Get(mock.Anything).\n    Run(func(path string) { fmt.Println(path, \"was called\") }).\n    // Can still use return functions by getting the embedded mock.Call\n    Call.Return(func(path string) string { return \"result for \" + path }, nil)\n</code></pre></p>"},{"location":"changelog/#v200-major-update","title":"<code>v2.0.0</code>: Major Update","text":"<p>This is the first major update of mockery. Version 2 brings a handful of improvements to mockery:</p> <ul> <li>Structured and pretty console logging</li> <li>CLI now switches over to sp13/cobra</li> <li>Use of viper configuration parsing. You can now use a .mockery.yaml config file in your repository</li> <li>Various CI fixes and improvements</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>All configuration is specified in a <code>.mockery.yml</code> file. An example config file may look like this:</p> YAML<pre><code>all: False\nboilerplate-file: ./path/to/boilerplate.txt\ntemplate: mockery\npackages:\n  github.com/vektra/example:\n    config:\n      # Make use of the template variables to place the mock in the same\n      # directory as the original interface.\n      dir: \"{{.InterfaceDir}}\"\n      filename: \"mocks_test.go\"\n      outpkg: \"{{.PackageName}}_test\"\n      mockname: \"Mock{{.InterfaceName}}\"\n    interfaces:\n      Foo:\n      Bar:\n        config:\n          # Make it unexported instead\n          mockname: \"mock{{.InterfaceName}}\"\n      Baz:\n        # Create two mock implementations of Baz with different names.\n        configs:\n          - filename: \"mocks_baz_one_test.go\"\n            mockname: \"MockBazOne\"\n          - filename: \"mocks_baz_two_test.go\"\n            mockname: \"MockBazTwo\"\n  io:\n    config:\n      dir: path/to/io/mocks\n      filename: \"mocks_io.go\"\n</code></pre> <p>These are the highlights of the config scheme:</p> <ol> <li>The parameters are merged hierarchically</li> <li>There are a number of template variables available to generalize config values.</li> <li>The style of mock to be generated is specified using the <code>template</code> parameter.</li> </ol> <p>An output file may contain multiple mocks, but the only rule is that all the mocks in the file must come from the same package. Because of this, mocks for different packages must go in different files.</p>"},{"location":"configuration/#parameter-descriptions","title":"Parameter Descriptions","text":"name templated default description <code>all</code> <code>false</code> Generate all interfaces for the specified packages. <code>_anchors</code> <code>{}</code> Unused by mockery, but allowed in the config schema so that you may define arbitrary yaml anchors. <code>boilerplate-file</code> <code>\"\"</code> Specify a path to a file that contains comments you want displayed at the top of all generated mock files. This is commonly used to display license headers at the top of your source code. <code>config</code> <code>\"\"</code> Set the location of the mockery config file. <code>dir</code> <code>\"mocks/{{.SrcPackagePath}}\"</code> The directory where the mock file will be outputted to. <code>exclude</code> <code>[]</code> Specify subpackages to exclude when using <code>recursive: True</code> <code>exclude-regex</code> <code>\"\"</code> When set along with <code>include-regex</code>, then interfaces which match <code>include-regex</code> but also match <code>exclude-regex</code> will not be generated. If <code>all</code> is set, or if <code>include-regex</code> is not set, then <code>exclude-regex</code> has no effect. <code>filename</code> <code>\"mock_{{.InterfaceName}}.go\"</code> The name of the file the mock will reside in. <code>formatter</code> <code>\"goimports\"</code> The formatter to use on the rendered template. Choices are: <code>gofmt</code>, <code>goimports</code>, <code>noop</code>. <code>include-regex</code> <code>\"\"</code> When set, only interface names that match the expression will be generated. This setting is ignored if <code>all: True</code> is specified in the configuration. To further refine the interfaces generated, use <code>exclude-regex</code>. <code>log-level</code> <code>\"info\"</code> Set the level of the logger <code>mock-build-tags</code> <code>\"\"</code> Set the build tags of the generated mocks. Read more about the format. <code>mockname</code> <code>\"Mock{{.InterfaceName}}\"</code> The name of the generated mock. <code>outpkg</code> <code>\"{{.PackageName}}\"</code> Use <code>outpkg</code> to specify the package name of the generated mocks. <code>packages</code> <code>null</code> A dictionary containing configuration describing the packages and interfaces to generate mocks for. <code>pkgname</code> <code>\"{{.SrcPackageName}}\" | The</code>#!go package name` given to the generated mock files. <code>recursive</code> <code>false</code> When set to <code>true</code> on a particular package, mockery will recursively search for all sub-packages and inject those packages into the config map. <code>tags</code> <code>\"\"</code> A space-separated list of additional build tags to load packages. <code>template</code> <code>\"\"</code> The template to use. The choices are <code>moq</code>, <code>mockery</code>, or a file path provided by <code>file://path/to/file.txt</code>. <code>template-data</code> <code>{}</code> A <code>map[string]any</code> that provides arbitrary options to the template. Each template will have a different set of accepted keys. Refer to each template's documentation for more details."},{"location":"configuration/#merging-precedence","title":"Merging Precedence","text":"<p>The configuration applied to a specific mocked interface is merged according to the following precedence (in decreasing priority):</p> <ol> <li>Interface-specific config in <code>.mockery.yaml</code></li> <li>Package-specific config in <code>.mockery.yaml</code></li> <li>Command-line options</li> <li>Environment variables</li> <li>Top-level defaults in <code>.mockery.yaml</code></li> </ol>"},{"location":"configuration/#formatting","title":"Formatting","text":"<p>If a parameter is named <code>enable-feature</code> and we want a value of <code>True</code>, then these are the formats for each source:</p> source value command line <code>--enable-feature=true</code> Environment variable <code>MOCKERY_ENABLE_FEATURE=True</code> yaml <code>enable-feature: True</code>"},{"location":"deprecations/","title":"Deprecations","text":""},{"location":"deprecations/#packages","title":"<code>packages</code>","text":"<p>To resolve this warning, use the <code>packages</code> feature:</p> .mockery.yaml<pre><code>packages:\n    [...]\n</code></pre> <p>The <code>packages</code> feature will be the only way to configure mockery in the future.</p>"},{"location":"deprecations/#issue-845-fix","title":"<code>issue-845-fix</code>","text":"<p>To resolve this warning:</p> .mockery.yaml<pre><code>issue-845-fix: True\n</code></pre> <p>This parameter fixes a somewhat uninteresting, but important issue found in #845. In short, mockery ignored the <code>outpkg:</code> parameter if <code>inpackage:</code> was set to <code>True</code>. This prevents users from being able to set alternate package names for their mocks that are generated in the same directory as the mocked interface. For example, it's legal Go to append <code>_test</code> to the mock package name if the file is appended with <code>_test.go</code> as well. This parameter will be permanently enabled in mockery v3.</p> <p>As an example, if you had configuration that looked like this:</p> YAML<pre><code>all: True\ndir: \"{{.InterfaceDir}}\"\nmockname: \"{{.InterfaceName}}Mock\"\noutpkg: \"{{.PackageName}}_test\"\nfilename: \"mock_{{.InterfaceName}}_test.go\"\ninpackage: True\n</code></pre> <p>The <code>outpkg</code> parameter would not be respected and instead would be forced to take on the value of <code>\"{{.PackageName}}\"</code>. To remove the warning, you must set:</p> YAML<pre><code>issue-845-fix: True\n</code></pre> <p>After this is done, mocks generated in the old scheme will properly respect the <code>outpkg:</code> parameter previously set if being generated with <code>inpackage: True</code>.</p>"},{"location":"deprecations/#resolve-type-alias","title":"<code>resolve-type-alias</code>","text":"<p>To resolve this warning:</p> .mockery.yaml<pre><code>resolve-type-alias: False\n</code></pre> <p>This parameter directs Mockery on whether it should resolve a type alias to its underlying, real type or if it should generate mocks by referencing the alias. Mockery was changed in #808 to support a new language feature that exposed type aliases in the parsed syntax tree. This meant that Mockery was now explicitly aware of aliases, which fixed a number of problems:</p> <ul> <li>#803</li> <li>#331</li> </ul> <p>However, it was discovered in #839 that this was in fact a backwards-incompatible change. Thus, to maintain backwards compatability guarantees, we created this parameter that will be set to <code>True</code> by default.</p> <p>For all new projects that use Mockery, there is no reason to resolve type aliases so this parameter should almost always be set to <code>False</code>. This will be the permanent behavior in Mockery v3.</p>"},{"location":"deprecations/#with-expecter","title":"<code>with-expecter</code>","text":"<p>To resolve this warning:</p> .mockery.yaml<pre><code>with-expecter: True\n</code></pre> <p>This parameter enables the expecter structs. In Mockery v3, this parameter will be permanently enabled. In order to remove the deprecation warning, you must set this parameter to <code>with-expecter: True</code>.</p>"},{"location":"examples/","title":"Examples","text":"<p>Tip</p> <p>IDEs are really useful when interacting with mockery objects. All mockery objects embed the <code>github.com/stretchr/testify/mock.Mock</code> object so you have access to both methods provided by mockery, and from testify itself. IDE auto-completion will show you all methods available for your use.</p>"},{"location":"examples/#simple-case","title":"Simple case","text":"<p>Given this interface:</p> string.go<pre><code>package example_project\n\ntype Stringer interface {\n    String() string\n}\n</code></pre> <p>Create a mock for this interface by specifying it in your config. We can then create a test using this new mock object:</p> string_test.go<pre><code>package example_project\n\nimport (\n    \"testing\"\n\n    \"github.com/stretchr/testify/assert\"\n)\n\nfunc Foo(s Stringer) string {\n    return s.String()\n}\n\nfunc TestString(t *testing.T) {\n    mockStringer := NewMockStringer(t)\n    mockStringer.EXPECT().String().Return(\"mockery\")\n    assert.Equal(t, \"mockery\", Foo(mockStringer))\n}\n</code></pre> <p>Note that in combination with using the mock's constructor and the <code>.EXPECT()</code> directives, your test will automatically fail if the expected call is not made. </p> Alternate way of specifying expectations <p>You can also use the <code>github.com/stretchr/testify/mock.Mock</code> object directly (instead of using the <code>.EXPECT()</code> methods, which provide type-safe-ish assertions).</p> string_test.go<pre><code>func TestString(t *testing.T) {\n    mockStringer := NewMockStringer(t)\n    mockStringer.On(\"String\").Return(\"mockery\")\n    assert.Equal(t, \"mockery\", Foo(mockStringer))\n}\n</code></pre> <p>We recommend always interacting with the assertions through <code>.EXPECT()</code> as mockery auto-generates methods that call out to <code>Mock.On()</code> themselves, providing you with some amount of compile-time safety. Consider if all your expectations for <code>String()</code> use the <code>Mock.On()</code> methods, and you decide to add an argument to <code>String()</code> to become <code>String(foo string)</code>. Now, your existing tests will only fail when you run them. If you had used <code>.EXPECT()</code> and regenerated your mocks after changing the function signature, your IDE, and the go compiler itself, would both tell you immediately that your expectations don't match the function signature. </p>"},{"location":"examples/#function-type-case","title":"Function type case","text":"<p>Bug</p> <p>Generating mocks for function types is likely not functioning in the <code>packages</code> config semantics. You'll likely need to revert to the legacy semantics as shown below.</p> <p>Given this is in <code>send.go</code></p> Go<pre><code>package test\n\ntype SendFunc func(data string) (int, error)\n</code></pre> <p>Run: <code>mockery --name=SendFunc</code> and the following will be output:</p> mock_SendFunc_test.go<pre><code>package mocks\n\nimport (\n    \"github.com/stretchr/testify/mock\"\n\n    testing \"testing\"\n)\n\ntype SendFunc struct {\n    mock.Mock\n}\n\nfunc (_m *SendFunc) Execute(data string) (int, error) {\n    ret := _m.Called(data)\n\n    var r0 int\n    if rf, ok := ret.Get(0).(func(string) int); ok {\n        r0 = rf(data)\n    } else {\n        r0 = ret.Get(0).(int)\n    }\n\n    var r1 error\n    if rf, ok := ret.Get(1).(func(string) error); ok {\n        r1 = rf(data)\n    } else {\n        r1 = ret.Error(1)\n    }\n\n    return r0, r1\n}\n\n// NewSendFunc creates a new instance of SendFunc. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.\nfunc NewSendFunc(t testing.TB) *SendFunc {\n    mock := &amp;SendFunc{}\n    mock.Mock.Test(t)\n\n    t.Cleanup(func() { mock.AssertExpectations(t) })\n\n    return mock\n}\n</code></pre>"},{"location":"examples/#return-value-provider-functions","title":"Return Value Provider Functions","text":"<p>If your tests need access to the arguments to calculate the return values, set the return value to a function that takes the method's arguments as its own arguments and returns the return value. For example, given this interface:</p> Go<pre><code>package test\n\ntype Proxy interface {\n  passthrough(ctx context.Context, s string) string\n}\n</code></pre> <p>The argument can be passed through as the return value:</p> Go<pre><code>import . \"github.com/stretchr/testify/mock\"\n\nproxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\n    Return(func(ctx context.Context, s string) string {\n        return s\n    })\n</code></pre>"},{"location":"features/","title":"Features","text":""},{"location":"features/#replace-types","title":"Replace Types","text":"<p> v2.23.0</p> <p>The <code>replace-type</code> parameter allows adding a list of type replacements to be made in package and/or type names. This can help overcome issues like usage of type aliases that point to internal packages.</p> <p>The format of the parameter is:</p> <p><code>originalPackagePath.originalTypeName=newPackageName:newPackagePath.newTypeName</code></p> <p>For example:</p> Bash<pre><code>mockery --replace-type github.com/vektra/mockery/v3/baz/internal/foo.InternalBaz=baz:github.com/vektra/mockery/v3/baz.Baz\n</code></pre> <p>This will replace any imported named <code>\"github.com/vektra/mockery/v3/baz/internal/foo\"</code> with <code>baz \"github.com/vektra/mockery/v3/baz\"</code>. The alias is defined with <code>:</code> before the package name. Also, the <code>InternalBaz</code> type that comes from this package will be renamed to <code>baz.Baz</code>.</p> <p>This next example fixes a common problem of type aliases that point to an internal package.</p> <p><code>cloud.google.com/go/pubsub.Message</code> is a type alias defined like this:</p> Go<pre><code>import (\n    ipubsub \"cloud.google.com/go/internal/pubsub\"\n)\n\ntype Message = ipubsub.Message\n</code></pre> <p>The Go parser that mockery uses doesn't provide a way to detect this alias and sends the application the package and type name of the type in the internal package, which will not work.</p> <p>We can use <code>replace-type</code> with only the package part to replace any import of <code>cloud.google.com/go/internal/pubsub</code> to <code>cloud.google.com/go/pubsub</code>. We don't need to change the alias or type name in this case, because they are <code>pubsub</code> and <code>Message</code> in both cases.</p> Bash<pre><code>mockery --replace-type cloud.google.com/go/internal/pubsub=cloud.google.com/go/pubsub\n</code></pre> <p>Original source:</p> Go<pre><code>import (\n    \"cloud.google.com/go/pubsub\"\n)\n\ntype Handler struct {\n    HandleMessage(m pubsub.Message) error\n}\n</code></pre> <p>Invalid mock generated without this parameter (points to an <code>internal</code> folder):</p> Go<pre><code>import (\n    mock \"github.com/stretchr/testify/mock\"\n\n    pubsub \"cloud.google.com/go/internal/pubsub\"\n)\n\nfunc (_m *Handler) HandleMessage(m pubsub.Message) error {\n    // ...\n    return nil\n}\n</code></pre> <p>Correct mock generated with this parameter.</p> Go<pre><code>import (\n    mock \"github.com/stretchr/testify/mock\"\n\n    pubsub \"cloud.google.com/go/pubsub\"\n)\n\nfunc (_m *Handler) HandleMessage(m pubsub.Message) error {\n    // ...\n    return nil\n}\n</code></pre> <p>Generic type constraints can also be replaced by targeting the changed parameter with the square bracket notation on the left-hand side.</p> Bash<pre><code>mockery --replace-type github.com/vektra/mockery/v3/baz/internal/foo.InternalBaz[T]=github.com/vektra/mockery/v3/baz.Baz\n</code></pre> <p>For example:</p> Go<pre><code>type InternalBaz[T any] struct{}\n\nfunc (*InternalBaz[T]) Foo() T {}\n\n// Becomes\ntype InternalBaz[T baz.Baz] struct{}\n\nfunc (*InternalBaz[T]) Foo() T {}\n</code></pre> <p>If a type constraint needs to be removed and replaced with a type, target the constraint with square brackets and include a '-' in front to have it removed.</p> Bash<pre><code>mockery --replace-type github.com/vektra/mockery/v3/baz/internal/foo.InternalBaz[-T]=github.com/vektra/mockery/v3/baz.Baz\n</code></pre> <p>For example:</p> Go<pre><code>type InternalBaz[T any] struct{}\n\nfunc (*InternalBaz[T]) Foo() T {}\n\n// Becomes\ntype InternalBaz struct{}\n\nfunc (*InternalBaz) Foo() baz.Baz {}\n</code></pre> <p>When replacing a generic constraint, you can replace the type with a pointer by adding a '*' before the output type name.</p> Bash<pre><code>mockery --replace-type github.com/vektra/mockery/v3/baz/internal/foo.InternalBaz[-T]=github.com/vektra/mockery/v3/baz.*Baz\n</code></pre> <p>For example:</p> Go<pre><code>type InternalBaz[T any] struct{}\n\nfunc (*InternalBaz[T]) Foo() T {}\n\n// Becomes\ntype InternalBaz struct{}\n\nfunc (*InternalBaz) Foo() *baz.Baz {}\n</code></pre>"},{"location":"features/#packages-configuration","title":"<code>packages</code> configuration","text":"<p> v2.21.0</p> <p>Info</p> <p>See the Migration Docs on how to migrate to this new feature.</p> <p>Mockery has a configuration parameter called <code>packages</code>. In this config section, you define the packages and the interfaces you want mocks generated for. The packages can be any arbitrary package, either your own project or anything within the Go ecosystem. You may provide package-level or interface-level overrides to the default config you provide.</p> <p>Usage of the <code>packages</code> config section is desirable for multiple reasons:</p> <ol> <li>Up to 5x increase in mock generation speed over the legacy method</li> <li>Granular control over interface generation, location, and file names</li> <li>Singular location for all config, instead of spread around by <code>//go:generate</code> statements</li> <li>Clean, easy to understand.</li> </ol>"},{"location":"features/#examples","title":"Examples","text":"<p>Here is an example configuration set:</p> YAML<pre><code>with-expecter: True\npackages:\n  github.com/vektra/mockery/v3/pkg: # (1)!\n    interfaces:\n      TypesPackage:\n      RequesterVariadic:\n        config: # (2)!\n          with-expecter: False \n        configs:\n          - mockname: MockRequesterVariadicOneArgument\n            unroll-variadic: False\n          - mockname: MockRequesterVariadic\n  io:\n    config:\n      all: True # (3)!\n    interfaces:\n      Writer:\n        config:\n          with-expecter: False # (4)!\n</code></pre> <ol> <li>For this package, we provide no package-level config (which means we inherit the defaults at the top-level). Since our default of <code>all:</code> is <code>False</code>, mockery will only generate the interfaces we specify. We tell it which interface to generate by using the <code>interfaces</code> section and specifying an empty map, one for each interface.</li> <li>There might be cases where you want multiple mocks generated from the same interface. To do this, you can define a default <code>config</code> section for the interface, and further <code>configs</code> (plural) section, one for each mock. You must specify a <code>mockname</code> for the mocks in this section to differentiate them.</li> <li>This is telling mockery to generate all interfaces in the <code>io</code> package.</li> <li>We can provide interface-specific overrides to the generation config.</li> </ol>"},{"location":"features/#templated-variables","title":"Templated variables","text":"<p>Note</p> <p>Templated variables are only available when using the <code>packages</code> config feature.</p> <p>Included with this feature is the ability to use templated strings for various configuration options. This is useful to define where your mocks are placed and how to name them. You can view the template variables available in the Configuration section of the docs.</p>"},{"location":"features/#recursive-package-discovery","title":"Recursive package discovery","text":"<p> v2.25.0</p> <p>When <code>recursive: true</code> is set on a particular package:</p> YAML<pre><code>packages:\n  github.com/user/project:\n    config:\n      recursive: true\n      with-expecter: true\n</code></pre> <p>mockery will dynamically discover all sub-packages within the specified package. This is done by calling <code>packages.Load</code> on the specified package, which induces Go to download the package from the internet (or simply your local project). Mockery then recursively discovers all sub-directories from the root package that also contain <code>.go</code> files and injects the respective package path into the config map as if you had specified them manually. As an example, your in-memory config map may end up looking like this:</p> YAML<pre><code>packages:\n  github.com/user/project:\n    config:\n      recursive: true\n      with-expecter: true\n  github.com/user/project/subpkg1:\n    config:\n      recursive: true\n      with-expecter: true\n  github.com/user/project/subpkg2:\n    config:\n      recursive: true\n      with-expecter: true\n</code></pre> <p>You can use the <code>showconfig</code> command to see the config mockery injects. The output of <code>showconfig</code> theoretically could be copy-pasted into your YAML file as it is semantically equivalent.</p> <p>mockery will not recurse into submodules, i.e. any subdirectory that contains a go.mod file. You must specify the submodule as a separate line item in the config if you would like mocks generated for it as well.</p> performance characteristics <p>The performance when using <code>recursive: true</code> may be worse than manually specifying all packages statically in the YAML file. This is because of the fact that mockery has to recursively walk the filesystem path that contains the package in question. It may unnecessarily walk down unrelated paths (for example, a Python virtual environment that is in the same path as your package). For this reason, it is recommended not to use <code>recursive: true</code> if it can be avoided.</p>"},{"location":"features/#regex-matching","title":"Regex matching","text":"<p>You can filter matched interfaces using the <code>include-regex</code> option. To generate mocks only for interfaces ending in <code>Client</code> we can use the following configuration:</p> YAML<pre><code>packages:\n  github.com/user/project:\n    config:\n      recursive: true\n      include-regex: \".*Client\"\n</code></pre> <p>To further refine matched interfaces, you can also use <code>exclude-regex</code>. If an interface matches both <code>include-regex</code> and <code>exclude-regex</code> then it will not be generated. For example, to generate all interfaces except those ending in <code>Func</code>:</p> YAML<pre><code>packages:\n  github.com/user/project:\n    config:\n      recursive: true\n      include-regex: \".*\"\n      exclude-regex: \".*Func\"\n</code></pre> <p>You can only use <code>exclude-regex</code> with <code>include-regex</code>. If set by itself, <code>exclude-regex</code> has no effect.</p> all: true <p>Using <code>all: true</code> will override <code>include-regex</code> (and <code>exclude-regex</code>) and issue a warning.</p>"},{"location":"features/#mock-constructors","title":"Mock Constructors","text":"<p> v2.11.0</p> <p>All mock objects have constructor functions. These constructors do basic test setup so that the expectations you set in the code are asserted before the test exits.</p> <p>Previously something like this would need to be done: Go<pre><code>factory := &amp;mocks.Factory{}\nfactory.Test(t) // so that mock does not panic when a method is unexpected\ndefer factory.AssertExpectations(t)\n</code></pre></p> <p>Instead, you may simply use the constructor: Go<pre><code>factory := mocks.NewFactory(t)\n</code></pre></p> <p>The constructor sets up common functionalities automatically</p> <ul> <li>The <code>AssertExpectations</code> method is registered to be called at the end of the tests via <code>t.Cleanup()</code> method.</li> <li>The testing.TB interface is registered on the <code>mock.Mock</code> so that tests don't panic when a call on the mock is unexpected.</li> </ul>"},{"location":"features/#expecter-structs","title":"Expecter Structs","text":"<p> v2.10.0 \u00b7 <code>with-expecter: True</code></p> <p>Mockery now supports an \"expecter\" struct, which allows your tests to use type-safe methods to generate call expectations. When enabled through the <code>with-expecter: True</code> mockery configuration, you can enter into the expecter interface by simply calling <code>.EXPECT()</code> on your mock object.</p> <p>For example, given an interface such as Go<pre><code>type Requester interface {\n    Get(path string) (string, error)\n}\n</code></pre></p> <p>You can use the expecter interface as such: Go<pre><code>requesterMock := mocks.NewRequester(t)\nrequesterMock.EXPECT().Get(\"some path\").Return(\"result\", nil)\n</code></pre></p> <p>A <code>RunAndReturn</code> method is also available on the expecter struct that allows you to dynamically set a return value based on the input to the mock's call.</p> Go<pre><code>requesterMock.EXPECT().\n    Get(mock.Anything).\n    RunAndReturn(func(path string) (string, error) { \n        fmt.Println(path, \"was called\")\n        return (\"result for \" + path), nil\n    })\n</code></pre> <p>Note</p> <p>Note that the types of the arguments on the <code>EXPECT</code> methods are <code>interface{}</code>, not the actual type of your interface. The reason for this is that you may want to pass <code>mock.Any</code> as an argument, which means that the argument you pass may be an arbitrary type. The types are still provided in the expecter method docstrings.</p>"},{"location":"features/#return-value-providers","title":"Return Value Providers","text":"<p> v2.20.0</p> <p>Return Value Providers can be used one of two ways. You may either define a single function with the exact same signature (number and type of input and return parameters) and pass that as a single value to <code>Return</code>, or you may pass multiple values to <code>Return</code> (one for each return parameter of the mocked function.)  If you are using the second form, for each of the return values of the mocked function, <code>Return</code> needs a function which takes the same arguments as the mocked function, and returns one of the return values. For example, if the return argument signature of <code>passthrough</code> in the above example was instead <code>(string, error)</code> in the interface, <code>Return</code> would also need a second function argument to define the error value:</p> Go<pre><code>type Proxy interface {\npassthrough(ctx context.Context, s string) (string, error)\n}\n</code></pre> <p>First form:</p> Go<pre><code>proxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\nReturn(\n    func(ctx context.Context, s string) (string, error) {\n        return s, nil\n    }\n)\n</code></pre> <p>Second form:</p> Go<pre><code>proxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\nReturn(\n    func(ctx context.Context, s string) string {\n        return s\n    },\n    func(ctx context.Context, s string) error {\n        return nil\n    },\n)\n</code></pre>"},{"location":"installation/","title":"Getting Started","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#github-release-recommended","title":"GitHub Release recommended","text":"<p>Visit the releases page to download one of the pre-built binaries for your platform.</p>"},{"location":"installation/#go-install","title":"go install","text":"<p>Supported, but not recommended: see wiki page and related discussions.</p> <p>Warning</p> <p>Do not use <code>@latest</code> as this will pull from the latest, potentially untagged, commit on master.</p>"},{"location":"installation/#docker","title":"Docker","text":"<p>Use the Docker image</p> Text Only<pre><code>docker pull vektra/mockery\n</code></pre> <p>Generate all the mocks for your project:</p> Text Only<pre><code>docker run -v \"$PWD\":/src -w /src vektra/mockery --all\n</code></pre>"},{"location":"installation/#homebrew","title":"Homebrew","text":"<p>Install through brew</p> Text Only<pre><code>brew install mockery\nbrew upgrade mockery\n</code></pre>"},{"location":"notes/","title":"Frequently Asked Questions","text":""},{"location":"notes/#error-no-go-files-found-in-root-search-path","title":"error: <code>no go files found in root search path</code>","text":"<p>When using the <code>packages</code> feature, <code>recursive: true</code> and you have specified a package that contains no <code>*.go</code> files, mockery is unable to determine the on-disk location of the package in order to continue the recursive package search. This appears to be a limitation of the golang.org/x/tools/go/packages package that is used to parse package metadata.</p> <p>The solution is to create a <code>.go</code> file in the package's path and add a <code>package [name]</code> directive at the top. It doesn't matter what the file is called. This allows mockery to properly read package metadata.</p> <p>Discussion</p>"},{"location":"notes/#internal-error-package-without-types-was-imported","title":"internal error: package without types was imported","text":"<p>https://github.com/vektra/mockery/issues/475</p> <p>This issue indicates that you have attempted to use package in your dependency tree (whether direct or indirect) that uses Go language semantics that your currently-running Go version does not support. The solution:</p> <ol> <li>Update to the latest go version</li> <li>Delete all cached packages with <code>go clean -modcache</code></li> <li>Reinstall mockery</li> </ol> <p>Additionally, this issue only happens when compiling mockery from source, such as with <code>go install</code>. Our docs recommend not to use <code>go install</code> as the success of your build depends on the compatibility of your Go version with the semantics in use. You would not encounter this issue if using one of the installation methods that install pre-built binaries, like downloading the <code>.tar.gz</code> binaries, or through <code>brew install</code>.</p>"},{"location":"notes/#multiple-expectations-with-identical-arguments","title":"Multiple Expectations With Identical Arguments","text":"<p>There might be instances where you want a mock to return different values on successive calls that provide the same arguments. For example, we might want to test this behavior:</p> Go<pre><code>// Return \"foo\" on the first call\ngetter := NewGetter()\nassert(t, \"foo\", getter.Get(\"key\"))\n\n// Return \"bar\" on the second call\nassert(t, \"bar\", getter.Get(\"key\"))\n</code></pre> <p>This can be done by using the <code>.Once()</code> method on the mock call expectation:</p> Go<pre><code>mockGetter := NewMockGetter(t)\nmockGetter.EXPECT().Get(mock.anything).Return(\"foo\").Once()\nmockGetter.EXPECT().Get(mock.anything).Return(\"bar\").Once()\n</code></pre> <p>Or you can identify an arbitrary number of times each value should be returned:</p> Go<pre><code>mockGetter := NewMockGetter(t)\nmockGetter.EXPECT().Get(mock.anything).Return(\"foo\").Times(4)\nmockGetter.EXPECT().Get(mock.anything).Return(\"bar\").Times(2)\n</code></pre> <p>Note that with proper Go support in your IDE, all the available methods are self-documented in autocompletion help contexts.</p>"},{"location":"notes/#variadic-arguments","title":"Variadic Arguments","text":"<p>Consider if we have a function <code>func Bar(message ...string) error</code>. A typical assertion might look like this:</p> Go<pre><code>func TestFoo(t *testing.T) {\n  m := NewMockFoo(t)\n  m.On(\"Bar\", \"hello\", \"world\").Return(nil)\n</code></pre> <p>We might also want to make an assertion that says \"any number of variadic arguments\":</p> Go<pre><code>m.On(\"Bar\", mock.Anything).Return(nil)\n</code></pre> <p>However, what we've given to mockery is ambiguous because it is impossible to distinguish between these two intentions:</p> <ol> <li>Any number of variadic arguments of any value</li> <li>A single variadic argument of any value</li> </ol> <p>This is fixed in #359 where you can provide <code>unroll-variadic: False</code> to get back to the old behavior. Thus, if you want to assert (1), you can then do:</p> Go<pre><code>m.On(\"Bar\", mock.Anything).Return(nil)\n</code></pre> <p>If you want to assert (2), you must set <code>unroll-variadic: True</code>. Then this assertion's intention will be modified to mean the second case:</p> Go<pre><code>m.On(\"Bar\", mock.Anything).Return(nil)\n</code></pre> <p>An upstream patch to <code>testify</code> is currently underway to allow passing <code>mock.Anything</code> directly to the variadic slice: https://github.com/stretchr/testify/pull/1348</p> <p>If this is merged, it would become possible to describe the above two cases respectively:</p> Go<pre><code>// case 1\nm.On(\"Bar\", mock.Anything).Return(nil)\n// case 2\nm.On(\"Bar\", []interface{}{mock.Anything}).Return(nil)\n</code></pre> <p>References:</p> <ul> <li>https://github.com/vektra/mockery/pull/359</li> <li>https://github.com/vektra/mockery/pull/123</li> <li>https://github.com/vektra/mockery/pull/550</li> <li>https://github.com/vektra/mockery/issues/541</li> </ul>"},{"location":"notes/#semantic-versioning","title":"Semantic Versioning","text":"<p>The versioning in this project applies only to the behavior of the mockery binary itself. This project explicitly does not promise a stable internal API, but rather a stable executable. The versioning applies to the following:</p> <ol> <li>CLI arguments.</li> <li>Parsing of Go code. New features in the Go language will be supported in a backwards-compatible manner, except during major version bumps.</li> <li>Behavior of mock objects. Mock objects can be considered to be part of the public API.</li> <li>Behavior of mockery given a set of arguments.</li> </ol> <p>What the version does not track:</p> <ol> <li>The interfaces, objects, methods etc. in the vektra/mockery package.</li> <li>Compatibility of <code>go get</code>-ing mockery with new or old versions of Go.</li> </ol>"},{"location":"notes/#mocking-interfaces-in-main","title":"Mocking interfaces in <code>main</code>","text":"<p>When your interfaces are in the main package, you should supply the <code>--inpackage</code> flag. This will generate mocks in the same package as the target code, avoiding import issues.</p>"},{"location":"notes/#mockery-fails-to-run-when-mockery_version-environment-variable-is-set","title":"mockery fails to run when <code>MOCKERY_VERSION</code> environment variable is set","text":"<p>This issue was first highlighted in this GitHub issue.</p> <p>mockery uses the viper package for configuration mapping and parsing. Viper is set to automatically search for all config variables specified in its config struct. One of the config variables is named <code>version</code>, which gets mapped to an environment variable called <code>MOCKERY_VERSION</code>. If you set this environment variable, mockery attempts to parse it into the <code>version</code> bool config.</p> <p>This is an adverse effect of how our config parsing is set up. The solution is to rename your environment variable to something other than <code>MOCKERY_VERSION</code>.</p>"},{"location":"running/","title":"Running","text":"<p>If your <code>.mockery.yaml</code> file has been populated with the packages and interfaces you want mocked, mockery can be run with no arguments. Take for example how the mockery project itself is configured:</p> YAML<pre><code>quiet: False\nkeeptree: True\ndisable-version-string: True\nwith-expecter: True\nmockname: \"{{.InterfaceName}}\"\nfilename: \"{{.MockName}}.go\"\noutpkg: mocks\npackages:\n  github.com/vektra/mockery/v3/pkg:\n    interfaces:\n      TypesPackage:\n# Lots more config...\n</code></pre> <p>From anywhere within your repo, you can simply call <code>mockery</code> once, and it will find your config either by respecting the <code>config</code> path you gave it, or by searching upwards from the current working directory.</p> Bash<pre><code>mockery\n08 Jul 23 01:40 EDT INF Starting mockery dry-run=false version=v2.31.0\n08 Jul 23 01:40 EDT INF Using config: /Users/landonclipp/git/LandonTClipp/mockery/.mockery.yaml dry-run=false version=v2.31.0\n</code></pre> <p>Command line arguments</p> <p>It is valid to specify arguments from the command line. The configuration precedence is specified in the Configuration docs.</p>"},{"location":"templates/","title":"Templates","text":"<p>Mockery, in its essence, renders templates. This project provides a number of pre-curated templates that you can select with the <code>template:</code> config parameter.</p>"},{"location":"templates/#template-options","title":"Template Options","text":""},{"location":"templates/#template-mockery","title":"<code>template: \"mockery\"</code>","text":"<p>Choosing this template will render a traditional \"mockery-style\" template. The section below shows what will be rendered for the given interface.</p> Interface<code>.mockery.yml</code><code>mocks.go</code>Example Usage Go<pre><code>package test\n\ntype Requester interface {\n    Get(path string) (string, error)\n}\n</code></pre> YAML<pre><code>template: mockery\npackages:\n    github.com/vektra/mockery/v3/pkg/fixtures:\n        config:\n            dir: \"{{.InterfaceDir}}\"\n            filename: \"mocks.go\"\n            pkgname: \"test\"\n            mockname: \"Mock{{.InterfaceName}}\"\n        interfaces:\n            Requester:\n</code></pre> Go<pre><code>// Code generated by mockery; DO NOT EDIT.\n// github.com/vektra/mockery\n\npackage test\n\nimport (\n    mock \"github.com/stretchr/testify/mock\"\n)\n\n\n// NewRequester creates a new instance of Requester. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.\n// The first argument is typically a *testing.T value.\nfunc NewRequester (t interface {\n    mock.TestingT\n    Cleanup(func())\n}) *Requester {\n   // ...\n}\n\n\n// Requester is an autogenerated mock type for the Requester type\ntype Requester struct {\n    mock.Mock\n}\n\ntype Requester_Expecter struct {\n    mock *mock.Mock\n}\n\nfunc (_m *Requester) EXPECT() *Requester_Expecter {\n    // ...\n}\n\n\n\n// Get provides a mock function for the type Requester\nfunc (_mock *Requester) Get(path string) (string, error) {\n    // ...\n}\n\n\n\n// Requester_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'\ntype Requester_Get_Call struct {\n    *mock.Call\n}\n\n\n\n// Get is a helper method to define mock.On call\n//  - path\nfunc (_e *Requester_Expecter) Get(path interface{}, ) *Requester_Get_Call {\n    // ...\n}\n\nfunc (_c *Requester_Get_Call) Run(run func(path string)) *Requester_Get_Call {\n   // ...\n}\n\nfunc (_c *Requester_Get_Call) Return(s string, err error) *Requester_Get_Call {\n    // ...\n}\n\nfunc (_c *Requester_Get_Call) RunAndReturn(run func(path string)(string, error)) *Requester_Get_Call {\n    // ...\n}\n</code></pre> Go<pre><code>package test\n\nimport (\n    \"testing\"\n\n    \"github.com/stretchr/testify/assert\"\n)\n\nfunc TestRequesterMock(t *testing.T) {\n    m := NewMockRequester(t)\n    m.EXPECT().Get(\"foo\").Return(\"bar\", nil).Once()\n    retString, err := m.Get(\"foo\")\n    assert.NoError(t, err)\n    assert.Equal(t, retString, \"bar\")\n}\n</code></pre> <p>As you can see, this mock utilizes <code>github.com/stretchr/testify</code> under the hood and registers call expectations with testify. When the mock receives a call to <code>Get()</code>, it retrieves the expected value from testify to be returned.</p> <p>This style of mock also has other interesting methods:</p> <code>Run()</code><code>RunAndReturn()</code><code>github.com/stretchr/testify/mock.Mock</code> <p>Run a side effect when the argument matches.</p> Go<pre><code>func TestRequesterMockRun(t *testing.T) {\n    m := NewMockRequester(t)\n    m.EXPECT().Get(mock.Anything).Return(\"\", nil)\n    m.EXPECT().Get(mock.Anything).Run(func(path string) {\n        fmt.Printf(\"Side effect! Argument is: %s\", path)\n    })\n    retString, err := m.Get(\"hello\")\n    assert.NoError(t, err)\n    assert.Equal(t, retString, \"\")\n}\n</code></pre> <p>Run a function to perform side-effects, and return the result of the function.</p> Go<pre><code>func TestRequesterMockRunAndReturn(t *testing.T) {\n    m := NewMockRequester(t)\n    m.EXPECT().Get(mock.Anything).RunAndReturn(func(path string) (string, error) {\n        return path + \" world\", nil\n    })\n    retString, err := m.Get(\"hello\")\n    assert.NoError(t, err)\n    assert.Equal(t, retString, \"hello world\")\n}\n</code></pre> <p>Because the mock embeds the testify <code>Mock</code> object, you can all any methods on that as well.</p> Go<pre><code>func TestRequesterMockTestifyEmbed(t *testing.T) {\n    m := NewMockRequester(t)\n    m.EXPECT().Get(mock.Anything).Return(\"\", nil).Twice()\n    m.Get(\"hello\")\n    m.Get(\"world\")\n    assert.Equal(t, len(m.Mock.Calls), 2)\n}\n</code></pre>"},{"location":"templates/#template-data","title":"<code>template-data</code>","text":"key type description <code>unroll-variadic</code> <code>bool</code> If set to <code>true</code>, will expand the variadic argument to testify using the <code>...</code> syntax. See notes for more details."},{"location":"templates/#template-moq","title":"<code>template: \"moq\"</code>","text":"<p><code>moq</code> templates draw from the mocks generated from the project at https://github.com/matryer/moq. This project was folded into mockery, and thus moq-style mocks can be natively generated from within mockery.</p> Interface<code>.mockery.yml</code><code>mocks_moq.go</code>Example Usage Go<pre><code>package test\n\ntype Requester interface {\n    Get(path string) (string, error)\n}\n</code></pre> YAML<pre><code>template: moq\npackages:\n    github.com/vektra/mockery/v3/pkg/fixtures:\n        config:\n            dir: \"{{.InterfaceDir}}\"\n            filename: \"mocks_moq.go\"\n            pkgname: \"test\"\n            mockname: \"Moq{{.InterfaceName}}\"\n        interfaces:\n            Requester:\n</code></pre> Go<pre><code>// Code generated by mockery; DO NOT EDIT.\n// github.com/vektra/mockery\n\npackage test\n\nimport (\n    \"sync\"\n)\n\n// Ensure, that MoqRequester does implement Requester.\n// If this is not the case, regenerate this file with moq.\nvar _ Requester = &amp;MoqRequester{}\n\n// MoqRequester is a mock implementation of Requester.\n//\n//  func TestSomethingThatUsesRequester(t *testing.T) {\n//\n//      // make and configure a mocked Requester\n//      mockedRequester := &amp;MoqRequester{\n//          GetFunc: func(path string) (string, error) {\n//              panic(\"mock out the Get method\")\n//          },\n//      }\n//\n//      // use mockedRequester in code that requires Requester\n//      // and then make assertions.\n//\n//  }\ntype MoqRequester struct {\n    // GetFunc mocks the Get method.\n    GetFunc func(path string) (string, error)\n\n    // calls tracks calls to the methods.\n    calls struct {\n        // Get holds details about calls to the Get method.\n        Get []struct {\n            // Path is the path argument value.\n            Path string\n        }\n    }\n    lockGet sync.RWMutex\n}\n\n// Get calls GetFunc.\nfunc (mock *MoqRequester) Get(path string) (string, error) {\n   // ...\n}\n\n// GetCalls gets all the calls that were made to Get.\n// Check the length with:\n//\n//  len(mockedRequester.GetCalls())\nfunc (mock *MoqRequester) GetCalls() []struct {\n    Path string\n} {\n    // ...\n}\n</code></pre> Go<pre><code>func TestRequesterMoq(t *testing.T) {\n    m := &amp;MoqRequester{\n        GetFunc: func(path string) (string, error) {\n            fmt.Printf(\"Go path: %s\\n\", path)\n            return path + \"/foo\", nil\n        },\n    }\n    result, err := m.Get(\"/path\")\n    assert.NoError(t, err)\n    assert.Equal(t, \"/path/foo\", result)\n}\n</code></pre> <p>Moq-style mocks are far simpler, and probably more intuitive, than mockery-style mocks. All that's needed is to define the function that will be run when the mock's method is called.</p>"},{"location":"templates/#template-data_1","title":"<code>template-data</code>","text":"<p><code>moq</code> accepts the following <code>template-data:</code> keys:</p> key type description <code>skip-ensure</code> <code>bool</code> Suppress mock implementation check, avoid import cycle if mocks generated outside of the tested package. <code>stub-impl</code> <code>bool</code> Return zero values when no mock implementation is provided, do not panic. <code>with-resets</code> <code>bool</code> Generates methods that allow resetting calls made to the mocks."},{"location":"templates/#template-file","title":"<code>template: \"file://</code>","text":"<p>You may also provide mockery a path to your own file using the <code>file://</code> protocol specifier. The string after <code>file://</code> will be the relative or absolute path of your template.</p>"},{"location":"templates/#data-provided-to-templates","title":"Data Provided To Templates","text":"<p>Mockery has two separate template instances: one for the <code>.mockery.yml</code> file, and one for the mock templates. Each instance has a different set of variables and functions available to it. All functions are pipeline-compatible.</p>"},{"location":"templates/#mockeryyml","title":"<code>.mockery.yml</code>","text":""},{"location":"templates/#functions","title":"Functions","text":"<p>As seen in the configuration section, mockery configuration has template variables and methods available to it. The functions available for use are defined in the <code>StringManipulationFuncs</code>.</p>"},{"location":"templates/#variables","title":"Variables","text":"<p>The variables available are defined in the <code>template.ConfigData</code> struct.</p>"},{"location":"templates/#template-files","title":"Template Files","text":""},{"location":"templates/#functions_1","title":"Functions","text":"<p>Template files have both <code>StringManipulationFuncs</code> and <code>TemplateMockFuncs</code> available as functions.</p>"},{"location":"templates/#variables_1","title":"Variables","text":"<p>The template is supplied with the <code>template.Data</code> struct. Some attributes return types such as <code>template.MockData</code> and <code>registry.Package</code> which themselves contain methods that may also be called.</p>"}]}
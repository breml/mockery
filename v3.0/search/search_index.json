{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"mockery","text":"<p>Alpha Test</p> <p>Mockery <code>v3</code> is currently in alpha and should not be used for production.</p> <p>Mockery is a project that creates mock implementations of Golang interfaces. It inspects source code and generates implementations of the interface that aid in testing.</p> <p>In addition to providing a number of different styles of mocks, mockery also allows users to provide their own template files that will then be rendered using a set of template data, methods, and functions that provide comprehensive typing information about the Go interface in question.</p> <p> </p>"},{"location":"#why-mockery","title":"Why mockery?","text":"<p>When you have an interface like this:</p> db.go<pre><code>type DB interface {\n    Get(val string) string\n}\n</code></pre> <p>and a function that takes this interface:</p> db_getter.go<pre><code>func getFromDB(db DB) string {\n    return db.Get(\"ice cream\")\n}\n</code></pre> <p>We can use simple configuration to generate a mock implementation for the interface:</p> .mockery.yaml<pre><code>packages:\n    github.com/org/repo:\n        interfaces:\n            DB:\n</code></pre> Bash<pre><code>$ mockery\n05 Mar 23 21:49 CST INF Starting mockery dry-run=false version=v3.0.0\n05 Mar 23 21:49 CST INF Using config: .mockery.yaml dry-run=false version=v3.0.0\n05 Mar 23 21:49 CST INF Generating mock dry-run=false interface=DB qualified-name=github.com/org/repo version=v3.0.0\n</code></pre> <p>We can then use the mock object in a test:</p> db_getter_test.go<pre><code>import (\n    \"testing\"\n\n    \"github.com/stretchr/testify/assert\"\n)\n\nfunc Test_getFromDB(t *testing.T) {\n    mockDB := NewMockDB(t)\n    mockDB.EXPECT().Get(\"ice cream\").Return(\"chocolate\").Once()\n    flavor := getFromDB(mockDB)\n    assert.Equal(t, \"chocolate\", flavor)\n}\n</code></pre>"},{"location":"#why-use-mockery","title":"Why use mockery?","text":"<ol> <li>You gain access to a number of pre-curated mock implementations that can be used in testing. This includes traditional \"mockery-style\" mocks, as well as other styles from the open source community such as from https://github.com/matryer/moq. Such mocks allow you to quickly define how the implementation should behave under test without having to manually curate your own mocks/stubs/fakes.</li> <li>Mockery benefits from a large number of performance improvements that almost all other Go code-generation projects currently have not employed. This means that it's orders of magnitude faster for large codebases.</li> <li>Mockery provides a comprehensive, centralized, flexible, and simple configuration scheme driven off of yaml instead of relying on sprawling <code>//go:generate</code> commands.</li> <li>Mockery is a code-generation framework. While its original goal is to provide mock implementations for testing purposes, users can supply their own templates to auto-generate any kind of code that needs to be based off of interfaces.</li> <li>A number of high profile companies, projects, and communities trust Mockery.</li> </ol>"},{"location":"#who-uses-mockery","title":"Who uses mockery?","text":"<ul> <li> Grafana </li> <li> Google Skia </li> <li> Google Skyzkaller </li> <li> Hashicorp </li> <li> Jaegertracing </li> <li> Splunk kafka-mq-go </li> <li> </li> <li> </li> <li> </li> <li></li> <li> eksctl </li> <li> </li> <li> Task <li> <p>Get Started</p>"},{"location":"configuration/","title":"Configuration","text":"<p>All configuration is specified in a <code>.mockery.yml</code> file. An example config file may look like this:</p> YAML<pre><code>all: False\ntemplate-data:\n  boilerplate-file: ./path/to/boilerplate.txt\ntemplate: mockery\npackages:\n  github.com/vektra/example:\n    config:\n      # Make use of the template variables to place the mock in the same\n      # directory as the original interface.\n      dir: \"{{.InterfaceDir}}\"\n      filename: \"mocks_test.go\"\n      outpkg: \"{{.PackageName}}_test\"\n      mockname: \"Mock{{.InterfaceName}}\"\n    interfaces:\n      Foo:\n      Bar:\n        config:\n          # Make it unexported instead\n          mockname: \"mock{{.InterfaceName}}\"\n      Baz:\n        # Create two mock implementations of Baz with different names.\n        configs:\n          - filename: \"mocks_baz_one_test.go\"\n            mockname: \"MockBazOne\"\n          - filename: \"mocks_baz_two_test.go\"\n            mockname: \"MockBazTwo\"\n  io:\n    config:\n      dir: path/to/io/mocks\n      filename: \"mocks_io.go\"\n</code></pre> <p>These are the highlights of the config scheme:</p> <ol> <li>The parameters are merged hierarchically</li> <li>There are a number of template variables available to generalize config values.</li> <li>The style of mock to be generated is specified using the <code>template</code> parameter.</li> </ol> <p>An output file may contain multiple mocks, but the only rule is that all the mocks in the file must come from the same package. Because of this, mocks for different packages must go in different files.</p>"},{"location":"configuration/#parameter-descriptions","title":"Parameter Descriptions","text":"name templated default description <code>all</code> <code>false</code> Generate all interfaces for the specified packages. <code>_anchors</code> <code>{}</code> Unused by mockery, but allowed in the config schema so that you may define arbitrary yaml anchors. <code>config</code> <code>\"\"</code> Set the location of the mockery config file. <code>dir</code> <code>\"mocks/{{.SrcPackagePath}}\"</code> The directory where the mock file will be outputted to. <code>exclude-subpkg-regex</code> <code>[]</code> A list of regular expressions that denote which subpackages should be excluded when <code>recursive: true</code> <code>exclude-regex</code> <code>\"\"</code> When set along with <code>include-regex</code>, then interfaces which match <code>include-regex</code> but also match <code>exclude-regex</code> will not be generated. If <code>all</code> is set, or if <code>include-regex</code> is not set, then <code>exclude-regex</code> has no effect. <code>filename</code> <code>\"mock_{{.InterfaceName}}.go\"</code> The name of the file the mock will reside in. <code>formatter</code> <code>\"goimports\"</code> The formatter to use on the rendered template. Choices are: <code>gofmt</code>, <code>goimports</code>, <code>noop</code>. <code>include-regex</code> <code>\"\"</code> When set, only interface names that match the expression will be generated. This setting is ignored if <code>all: True</code> is specified in the configuration. To further refine the interfaces generated, use <code>exclude-regex</code>. <code>log-level</code> <code>\"info\"</code> Set the level of the logger <code>mockname</code> <code>\"Mock{{.InterfaceName}}\"</code> The name of the generated mock. <code>outpkg</code> <code>\"{{.PackageName}}\"</code> Use <code>outpkg</code> to specify the package name of the generated mocks. <code>packages</code> <code>null</code> A dictionary containing configuration describing the packages and interfaces to generate mocks for. <code>pkgname</code> <code>\"{{.SrcPackageName}}\" | The</code>#!go package name` given to the generated mock files. <code>recursive</code> <code>false</code> When set to <code>true</code> on a particular package, mockery will recursively search for all sub-packages and inject those packages into the config map. <code>tags</code> <code>\"\"</code> A space-separated list of additional build tags to load packages. <code>template</code> <code>\"\"</code> The template to use. The choices are <code>moq</code>, <code>mockery</code>, or a file path provided by <code>file://path/to/file.txt</code>. <code>template-data</code> <code>{}</code> A <code>map[string]any</code> that provides arbitrary options to the template. Each template will have a different set of accepted keys. Refer to each template's documentation for more details."},{"location":"configuration/#merging-precedence","title":"Merging Precedence","text":"<p>The configuration applied to a specific mocked interface is merged according to the following precedence (in decreasing priority):</p> <ol> <li>Interface-specific config in <code>.mockery.yaml</code></li> <li>Package-specific config in <code>.mockery.yaml</code></li> <li>Command-line options</li> <li>Environment variables</li> <li>Top-level defaults in <code>.mockery.yaml</code></li> </ol>"},{"location":"configuration/#formatting","title":"Formatting","text":"<p>If a parameter is named <code>enable-feature</code> and we want a value of <code>True</code>, then these are the formats for each source:</p> source value command line <code>--enable-feature=true</code> Environment variable <code>MOCKERY_ENABLE_FEATURE=True</code> yaml <code>enable-feature: True</code>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#error-no-go-files-found-in-root-search-path","title":"error: <code>no go files found in root search path</code>","text":"<p>When using the <code>packages</code> feature, <code>recursive: true</code> and you have specified a package that contains no <code>*.go</code> files, mockery is unable to determine the on-disk location of the package in order to continue the recursive package search. This appears to be a limitation of the golang.org/x/tools/go/packages package that is used to parse package metadata.</p> <p>The solution is to create a <code>.go</code> file in the package's path and add a <code>package [name]</code> directive at the top. It doesn't matter what the file is called. This allows mockery to properly read package metadata.</p> <p>Discussion</p>"},{"location":"faq/#internal-error-package-without-types-was-imported","title":"internal error: package without types was imported","text":"<p>https://github.com/vektra/mockery/issues/475</p> <p>This issue indicates that you have attempted to use package in your dependency tree (whether direct or indirect) that uses Go language semantics that your currently-running Go version does not support. The solution:</p> <ol> <li>Update to the latest go version</li> <li>Delete all cached packages with <code>go clean -modcache</code></li> <li>Reinstall mockery</li> </ol> <p>Additionally, this issue only happens when compiling mockery from source, such as with <code>go install</code>. Our docs recommend not to use <code>go install</code> as the success of your build depends on the compatibility of your Go version with the semantics in use. You would not encounter this issue if using one of the installation methods that install pre-built binaries, like downloading the <code>.tar.gz</code> binaries, or through <code>brew install</code>.</p>"},{"location":"faq/#multiple-expectations-with-identical-arguments","title":"Multiple Expectations With Identical Arguments","text":"<p>There might be instances where you want a mock to return different values on successive calls that provide the same arguments. For example, we might want to test this behavior:</p> Go<pre><code>// Return \"foo\" on the first call\ngetter := NewGetter()\nassert(t, \"foo\", getter.Get(\"key\"))\n\n// Return \"bar\" on the second call\nassert(t, \"bar\", getter.Get(\"key\"))\n</code></pre> <p>This can be done by using the <code>.Once()</code> method on the mock call expectation:</p> Go<pre><code>mockGetter := NewMockGetter(t)\nmockGetter.EXPECT().Get(mock.anything).Return(\"foo\").Once()\nmockGetter.EXPECT().Get(mock.anything).Return(\"bar\").Once()\n</code></pre> <p>Or you can identify an arbitrary number of times each value should be returned:</p> Go<pre><code>mockGetter := NewMockGetter(t)\nmockGetter.EXPECT().Get(mock.anything).Return(\"foo\").Times(4)\nmockGetter.EXPECT().Get(mock.anything).Return(\"bar\").Times(2)\n</code></pre> <p>Note that with proper Go support in your IDE, all the available methods are self-documented in autocompletion help contexts.</p>"},{"location":"faq/#variadic-arguments","title":"Variadic Arguments","text":"<p>Consider if we have a function <code>func Bar(message ...string) error</code>. A typical assertion might look like this:</p> Go<pre><code>func TestFoo(t *testing.T) {\n  m := NewMockFoo(t)\n  m.On(\"Bar\", \"hello\", \"world\").Return(nil)\n</code></pre> <p>We might also want to make an assertion that says \"any number of variadic arguments\":</p> Go<pre><code>m.On(\"Bar\", mock.Anything).Return(nil)\n</code></pre> <p>However, what we've given to mockery is ambiguous because it is impossible to distinguish between these two intentions:</p> <ol> <li>Any number of variadic arguments of any value</li> <li>A single variadic argument of any value</li> </ol> <p>This is fixed in #359 where you can provide <code>unroll-variadic: False</code> to get back to the old behavior. Thus, if you want to assert (1), you can then do:</p> Go<pre><code>m.On(\"Bar\", mock.Anything).Return(nil)\n</code></pre> <p>If you want to assert (2), you must set <code>unroll-variadic: True</code>. Then this assertion's intention will be modified to mean the second case:</p> Go<pre><code>m.On(\"Bar\", mock.Anything).Return(nil)\n</code></pre> <p>An upstream patch to <code>testify</code> is currently underway to allow passing <code>mock.Anything</code> directly to the variadic slice: https://github.com/stretchr/testify/pull/1348</p> <p>If this is merged, it would become possible to describe the above two cases respectively:</p> Go<pre><code>// case 1\nm.On(\"Bar\", mock.Anything).Return(nil)\n// case 2\nm.On(\"Bar\", []interface{}{mock.Anything}).Return(nil)\n</code></pre> <p>References:</p> <ul> <li>https://github.com/vektra/mockery/pull/359</li> <li>https://github.com/vektra/mockery/pull/123</li> <li>https://github.com/vektra/mockery/pull/550</li> <li>https://github.com/vektra/mockery/issues/541</li> </ul>"},{"location":"faq/#semantic-versioning","title":"Semantic Versioning","text":"<p>The versioning in this project applies only to the behavior of the mockery binary itself. This project explicitly does not promise a stable internal API, but rather a stable executable. The versioning applies to the following:</p> <ol> <li>CLI arguments.</li> <li>Parsing of Go code. New features in the Go language will be supported in a backwards-compatible manner, except during major version bumps.</li> <li>Behavior of mock objects. Mock objects can be considered to be part of the public API.</li> <li>Behavior of mockery given a set of arguments.</li> </ol> <p>What the version does not track:</p> <ol> <li>The interfaces, objects, methods etc. in the vektra/mockery package.</li> <li>Compatibility of <code>go get</code>-ing mockery with new or old versions of Go.</li> </ol>"},{"location":"faq/#mocking-interfaces-in-main","title":"Mocking interfaces in <code>main</code>","text":"<p>When your interfaces are in the main package, you should supply the <code>--inpackage</code> flag. This will generate mocks in the same package as the target code, avoiding import issues.</p>"},{"location":"faq/#mockery-fails-to-run-when-mockery_version-environment-variable-is-set","title":"mockery fails to run when <code>MOCKERY_VERSION</code> environment variable is set","text":"<p>This issue was first highlighted in this GitHub issue.</p> <p>mockery uses the viper package for configuration mapping and parsing. Viper is set to automatically search for all config variables specified in its config struct. One of the config variables is named <code>version</code>, which gets mapped to an environment variable called <code>MOCKERY_VERSION</code>. If you set this environment variable, mockery attempts to parse it into the <code>version</code> bool config.</p> <p>This is an adverse effect of how our config parsing is set up. The solution is to rename your environment variable to something other than <code>MOCKERY_VERSION</code>.</p>"},{"location":"installation/","title":"Getting Started","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#github-release-recommended","title":"GitHub Release recommended","text":"<p>Visit the releases page to download one of the pre-built binaries for your platform.</p>"},{"location":"installation/#go-install","title":"go install","text":"<p>Supported, but not recommended: see wiki page and related discussions.</p> <p>Warning</p> <p>Do not use <code>@latest</code> as this will pull from the latest, potentially untagged, commit on master.</p>"},{"location":"installation/#docker","title":"Docker","text":"<p>Use the Docker image</p> Text Only<pre><code>docker pull vektra/mockery\n</code></pre> <p>Generate all the mocks for your project:</p> Text Only<pre><code>docker run -v \"$PWD\":/src -w /src vektra/mockery --all\n</code></pre>"},{"location":"installation/#homebrew","title":"Homebrew","text":"<p>Install through brew</p> Text Only<pre><code>brew install mockery\nbrew upgrade mockery\n</code></pre>"},{"location":"running/","title":"Running","text":"<p>If your <code>.mockery.yaml</code> file has been populated with the packages and interfaces you want mocked, mockery can be run with no arguments. Take for example how the mockery project itself is configured:</p> YAML<pre><code>quiet: False\nkeeptree: True\ndisable-version-string: True\nwith-expecter: True\nmockname: \"{{.InterfaceName}}\"\nfilename: \"{{.MockName}}.go\"\noutpkg: mocks\npackages:\n  github.com/vektra/mockery/v3/pkg:\n    interfaces:\n      TypesPackage:\n# Lots more config...\n</code></pre> <p>From anywhere within your repo, you can simply call <code>mockery</code> once, and it will find your config either by respecting the <code>config</code> path you gave it, or by searching upwards from the current working directory.</p> Bash<pre><code>mockery\n08 Jul 23 01:40 EDT INF Starting mockery dry-run=false version=v2.31.0\n08 Jul 23 01:40 EDT INF Using config: /Users/landonclipp/git/LandonTClipp/mockery/.mockery.yaml dry-run=false version=v2.31.0\n</code></pre> <p>Command line arguments</p> <p>It is valid to specify arguments from the command line. The configuration precedence is specified in the Configuration docs.</p>"},{"location":"template-mockery/","title":"Mockery","text":"<p>Features for <code>template: mockery</code>.</p> <p>Choosing this template will render a traditional \"mockery-style\" template. The section below shows what will be rendered for the given interface.</p>"},{"location":"template-mockery/#description","title":"Description","text":"Interface<code>.mockery.yml</code><code>mocks.go</code>Example Usage Go<pre><code>package test\n\ntype Requester interface {\n    Get(path string) (string, error)\n}\n</code></pre> YAML<pre><code>template: mockery\npackages:\n    github.com/vektra/mockery/v3/pkg/fixtures:\n        config:\n            dir: \"{{.InterfaceDir}}\"\n            filename: \"mocks.go\"\n            pkgname: \"test\"\n            mockname: \"Mock{{.InterfaceName}}\"\n        interfaces:\n            Requester:\n</code></pre> Go<pre><code>// Code generated by mockery; DO NOT EDIT.\n// github.com/vektra/mockery\n\npackage test\n\nimport (\n    mock \"github.com/stretchr/testify/mock\"\n)\n\n\n// NewRequester creates a new instance of Requester. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.\n// The first argument is typically a *testing.T value.\nfunc NewRequester (t interface {\n    mock.TestingT\n    Cleanup(func())\n}) *Requester {\n   // ...\n}\n\n\n// Requester is an autogenerated mock type for the Requester type\ntype Requester struct {\n    mock.Mock\n}\n\ntype Requester_Expecter struct {\n    mock *mock.Mock\n}\n\nfunc (_m *Requester) EXPECT() *Requester_Expecter {\n    // ...\n}\n\n\n\n// Get provides a mock function for the type Requester\nfunc (_mock *Requester) Get(path string) (string, error) {\n    // ...\n}\n\n\n\n// Requester_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'\ntype Requester_Get_Call struct {\n    *mock.Call\n}\n\n\n\n// Get is a helper method to define mock.On call\n//  - path\nfunc (_e *Requester_Expecter) Get(path interface{}, ) *Requester_Get_Call {\n    // ...\n}\n\nfunc (_c *Requester_Get_Call) Run(run func(path string)) *Requester_Get_Call {\n   // ...\n}\n\nfunc (_c *Requester_Get_Call) Return(s string, err error) *Requester_Get_Call {\n    // ...\n}\n\nfunc (_c *Requester_Get_Call) RunAndReturn(run func(path string)(string, error)) *Requester_Get_Call {\n    // ...\n}\n</code></pre> Go<pre><code>package test\n\nimport (\n    \"testing\"\n\n    \"github.com/stretchr/testify/assert\"\n)\n\nfunc TestRequesterMock(t *testing.T) {\n    m := NewMockRequester(t)\n    m.EXPECT().Get(\"foo\").Return(\"bar\", nil).Once()\n    retString, err := m.Get(\"foo\")\n    assert.NoError(t, err)\n    assert.Equal(t, retString, \"bar\")\n}\n</code></pre> <p>As you can see, this mock utilizes <code>github.com/stretchr/testify</code> under the hood and registers call expectations with testify. When the mock receives a call to <code>Get()</code>, it retrieves the expected value from testify to be returned.</p> <p>This style of mock also has other interesting methods:</p> <code>Run()</code><code>RunAndReturn()</code><code>github.com/stretchr/testify/mock.Mock</code> <p>Run a side effect when the argument matches.</p> Go<pre><code>func TestRequesterMockRun(t *testing.T) {\n    m := NewMockRequester(t)\n    m.EXPECT().Get(mock.Anything).Return(\"\", nil)\n    m.EXPECT().Get(mock.Anything).Run(func(path string) {\n        fmt.Printf(\"Side effect! Argument is: %s\", path)\n    })\n    retString, err := m.Get(\"hello\")\n    assert.NoError(t, err)\n    assert.Equal(t, retString, \"\")\n}\n</code></pre> <p>Run a function to perform side-effects, and return the result of the function.</p> Go<pre><code>func TestRequesterMockRunAndReturn(t *testing.T) {\n    m := NewMockRequester(t)\n    m.EXPECT().Get(mock.Anything).RunAndReturn(func(path string) (string, error) {\n        return path + \" world\", nil\n    })\n    retString, err := m.Get(\"hello\")\n    assert.NoError(t, err)\n    assert.Equal(t, retString, \"hello world\")\n}\n</code></pre> <p>Because the mock embeds the testify <code>Mock</code> object, you can all any methods on that as well.</p> Go<pre><code>func TestRequesterMockTestifyEmbed(t *testing.T) {\n    m := NewMockRequester(t)\n    m.EXPECT().Get(mock.Anything).Return(\"\", nil).Twice()\n    m.Get(\"hello\")\n    m.Get(\"world\")\n    assert.Equal(t, len(m.Mock.Calls), 2)\n}\n</code></pre>"},{"location":"template-mockery/#template-data","title":"<code>template-data</code>","text":"key type description <code>boilerplate-file</code> <code>string</code> Specify a path to a file that contains comments you want displayed at the top of all generated mock files. This is commonly used to display license headers at the top of your source code. <code>mock-build-tags</code> <code>\"\"</code> Set the build tags of the generated mocks. Read more about the format. <code>unroll-variadic</code> <code>bool</code> If set to <code>unroll-variadic: true</code>, will expand the variadic argument to testify using the <code>...</code> syntax. See notes for more details."},{"location":"template-mockery/#features","title":"Features","text":""},{"location":"template-mockery/#replace-types","title":"Replace Types","text":"<p> v2.23.0</p> <p>The <code>replace-type</code> parameter allows adding a list of type replacements to be made in package and/or type names. This can help overcome issues like usage of type aliases that point to internal packages.</p> <p>The format of the parameter is:</p> <p><code>originalPackagePath.originalTypeName=newPackageName:newPackagePath.newTypeName</code></p> <p>For example:</p> Bash<pre><code>mockery --replace-type github.com/vektra/mockery/v3/baz/internal/foo.InternalBaz=baz:github.com/vektra/mockery/v3/baz.Baz\n</code></pre> <p>This will replace any imported named <code>\"github.com/vektra/mockery/v3/baz/internal/foo\"</code> with <code>baz \"github.com/vektra/mockery/v3/baz\"</code>. The alias is defined with <code>:</code> before the package name. Also, the <code>InternalBaz</code> type that comes from this package will be renamed to <code>baz.Baz</code>.</p> <p>This next example fixes a common problem of type aliases that point to an internal package.</p> <p><code>cloud.google.com/go/pubsub.Message</code> is a type alias defined like this:</p> Go<pre><code>import (\n    ipubsub \"cloud.google.com/go/internal/pubsub\"\n)\n\ntype Message = ipubsub.Message\n</code></pre> <p>The Go parser that mockery uses doesn't provide a way to detect this alias and sends the application the package and type name of the type in the internal package, which will not work.</p> <p>We can use <code>replace-type</code> with only the package part to replace any import of <code>cloud.google.com/go/internal/pubsub</code> to <code>cloud.google.com/go/pubsub</code>. We don't need to change the alias or type name in this case, because they are <code>pubsub</code> and <code>Message</code> in both cases.</p> Bash<pre><code>mockery --replace-type cloud.google.com/go/internal/pubsub=cloud.google.com/go/pubsub\n</code></pre> <p>Original source:</p> Go<pre><code>import (\n    \"cloud.google.com/go/pubsub\"\n)\n\ntype Handler struct {\n    HandleMessage(m pubsub.Message) error\n}\n</code></pre> <p>Invalid mock generated without this parameter (points to an <code>internal</code> folder):</p> Go<pre><code>import (\n    mock \"github.com/stretchr/testify/mock\"\n\n    pubsub \"cloud.google.com/go/internal/pubsub\"\n)\n\nfunc (_m *Handler) HandleMessage(m pubsub.Message) error {\n    // ...\n    return nil\n}\n</code></pre> <p>Correct mock generated with this parameter.</p> Go<pre><code>import (\n    mock \"github.com/stretchr/testify/mock\"\n\n    pubsub \"cloud.google.com/go/pubsub\"\n)\n\nfunc (_m *Handler) HandleMessage(m pubsub.Message) error {\n    // ...\n    return nil\n}\n</code></pre> <p>Generic type constraints can also be replaced by targeting the changed parameter with the square bracket notation on the left-hand side.</p> Bash<pre><code>mockery --replace-type github.com/vektra/mockery/v3/baz/internal/foo.InternalBaz[T]=github.com/vektra/mockery/v3/baz.Baz\n</code></pre> <p>For example:</p> Go<pre><code>type InternalBaz[T any] struct{}\n\nfunc (*InternalBaz[T]) Foo() T {}\n\n// Becomes\ntype InternalBaz[T baz.Baz] struct{}\n\nfunc (*InternalBaz[T]) Foo() T {}\n</code></pre> <p>If a type constraint needs to be removed and replaced with a type, target the constraint with square brackets and include a '-' in front to have it removed.</p> Bash<pre><code>mockery --replace-type github.com/vektra/mockery/v3/baz/internal/foo.InternalBaz[-T]=github.com/vektra/mockery/v3/baz.Baz\n</code></pre> <p>For example:</p> Go<pre><code>type InternalBaz[T any] struct{}\n\nfunc (*InternalBaz[T]) Foo() T {}\n\n// Becomes\ntype InternalBaz struct{}\n\nfunc (*InternalBaz) Foo() baz.Baz {}\n</code></pre> <p>When replacing a generic constraint, you can replace the type with a pointer by adding a '*' before the output type name.</p> Bash<pre><code>mockery --replace-type github.com/vektra/mockery/v3/baz/internal/foo.InternalBaz[-T]=github.com/vektra/mockery/v3/baz.*Baz\n</code></pre> <p>For example:</p> Go<pre><code>type InternalBaz[T any] struct{}\n\nfunc (*InternalBaz[T]) Foo() T {}\n\n// Becomes\ntype InternalBaz struct{}\n\nfunc (*InternalBaz) Foo() *baz.Baz {}\n</code></pre>"},{"location":"template-mockery/#mock-constructors","title":"Mock Constructors","text":"<p> v2.11.0</p> <p>All mock objects have constructor functions. These constructors do basic test setup so that the expectations you set in the code are asserted before the test exits.</p> <p>Previously something like this would need to be done: Go<pre><code>factory := &amp;mocks.Factory{}\nfactory.Test(t) // so that mock does not panic when a method is unexpected\ndefer factory.AssertExpectations(t)\n</code></pre></p> <p>Instead, you may simply use the constructor: Go<pre><code>factory := mocks.NewFactory(t)\n</code></pre></p> <p>The constructor sets up common functionalities automatically</p> <ul> <li>The <code>AssertExpectations</code> method is registered to be called at the end of the tests via <code>t.Cleanup()</code> method.</li> <li>The testing.TB interface is registered on the <code>mock.Mock</code> so that tests don't panic when a call on the mock is unexpected.</li> </ul>"},{"location":"template-mockery/#expecter-structs","title":"Expecter Structs","text":"<p> v2.10.0 \u00b7 <code>with-expecter: True</code></p> <p>Mockery now supports an \"expecter\" struct, which allows your tests to use type-safe methods to generate call expectations. When enabled through the <code>with-expecter: True</code> mockery configuration, you can enter into the expecter interface by simply calling <code>.EXPECT()</code> on your mock object.</p> <p>For example, given an interface such as Go<pre><code>type Requester interface {\n    Get(path string) (string, error)\n}\n</code></pre></p> <p>You can use the expecter interface as such: Go<pre><code>requesterMock := mocks.NewRequester(t)\nrequesterMock.EXPECT().Get(\"some path\").Return(\"result\", nil)\n</code></pre></p> <p>A <code>RunAndReturn</code> method is also available on the expecter struct that allows you to dynamically set a return value based on the input to the mock's call.</p> Go<pre><code>requesterMock.EXPECT().\n    Get(mock.Anything).\n    RunAndReturn(func(path string) (string, error) {\n        fmt.Println(path, \"was called\")\n        return (\"result for \" + path), nil\n    })\n</code></pre> <p>Note</p> <p>Note that the types of the arguments on the <code>EXPECT</code> methods are <code>interface{}</code>, not the actual type of your interface. The reason for this is that you may want to pass <code>mock.Any</code> as an argument, which means that the argument you pass may be an arbitrary type. The types are still provided in the expecter method docstrings.</p>"},{"location":"template-mockery/#return-value-providers","title":"Return Value Providers","text":"<p> v2.20.0</p> <p>Return Value Providers can be used one of two ways. You may either define a single function with the exact same signature (number and type of input and return parameters) and pass that as a single value to <code>Return</code>, or you may pass multiple values to <code>Return</code> (one for each return parameter of the mocked function.)  If you are using the second form, for each of the return values of the mocked function, <code>Return</code> needs a function which takes the same arguments as the mocked function, and returns one of the return values. For example, if the return argument signature of <code>passthrough</code> in the above example was instead <code>(string, error)</code> in the interface, <code>Return</code> would also need a second function argument to define the error value:</p> Go<pre><code>type Proxy interface {\n    passthrough(ctx context.Context, s string) (string, error)\n}\n</code></pre> <p>First form:</p> Go<pre><code>proxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\nReturn(\n    func(ctx context.Context, s string) (string, error) {\n        return s, nil\n    }\n)\n</code></pre> <p>Second form:</p> Go<pre><code>proxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\nReturn(\n    func(ctx context.Context, s string) string {\n        return s\n    },\n    func(ctx context.Context, s string) error {\n        return nil\n    },\n)\n</code></pre>"},{"location":"template-moq/","title":"Moq","text":""},{"location":"template-moq/#description","title":"Description","text":"Interface<code>.mockery.yml</code><code>mocks_moq.go</code>Example Usage Go<pre><code>package test\n\ntype Requester interface {\n    Get(path string) (string, error)\n}\n</code></pre> YAML<pre><code>template: moq\npackages:\n    github.com/vektra/mockery/v3/pkg/fixtures:\n        config:\n            dir: \"{{.InterfaceDir}}\"\n            filename: \"mocks_moq.go\"\n            pkgname: \"test\"\n            mockname: \"Moq{{.InterfaceName}}\"\n        interfaces:\n            Requester:\n</code></pre> Go<pre><code>// Code generated by mockery; DO NOT EDIT.\n// github.com/vektra/mockery\n\npackage test\n\nimport (\n    \"sync\"\n)\n\n// Ensure, that MoqRequester does implement Requester.\n// If this is not the case, regenerate this file with moq.\nvar _ Requester = &amp;MoqRequester{}\n\n// MoqRequester is a mock implementation of Requester.\n//\n//  func TestSomethingThatUsesRequester(t *testing.T) {\n//\n//      // make and configure a mocked Requester\n//      mockedRequester := &amp;MoqRequester{\n//          GetFunc: func(path string) (string, error) {\n//              panic(\"mock out the Get method\")\n//          },\n//      }\n//\n//      // use mockedRequester in code that requires Requester\n//      // and then make assertions.\n//\n//  }\ntype MoqRequester struct {\n    // GetFunc mocks the Get method.\n    GetFunc func(path string) (string, error)\n\n    // calls tracks calls to the methods.\n    calls struct {\n        // Get holds details about calls to the Get method.\n        Get []struct {\n            // Path is the path argument value.\n            Path string\n        }\n    }\n    lockGet sync.RWMutex\n}\n\n// Get calls GetFunc.\nfunc (mock *MoqRequester) Get(path string) (string, error) {\n   // ...\n}\n\n// GetCalls gets all the calls that were made to Get.\n// Check the length with:\n//\n//  len(mockedRequester.GetCalls())\nfunc (mock *MoqRequester) GetCalls() []struct {\n    Path string\n} {\n    // ...\n}\n</code></pre> Go<pre><code>func TestRequesterMoq(t *testing.T) {\n    m := &amp;MoqRequester{\n        GetFunc: func(path string) (string, error) {\n            fmt.Printf(\"Go path: %s\\n\", path)\n            return path + \"/foo\", nil\n        },\n    }\n    result, err := m.Get(\"/path\")\n    assert.NoError(t, err)\n    assert.Equal(t, \"/path/foo\", result)\n}\n</code></pre> <p>Moq-style mocks are far simpler, and probably more intuitive, than mockery-style mocks. All that's needed is to define the function that will be run when the mock's method is called.</p>"},{"location":"template-moq/#template-data","title":"<code>template-data</code>","text":"<p><code>moq</code> accepts the following <code>template-data:</code> keys:</p> key type description <code>boilerplate-file</code> <code>string</code> Specify a path to a file that contains comments you want displayed at the top of all generated mock files. This is commonly used to display license headers at the top of your source code. <code>mock-build-tags</code> <code>\"\"</code> Set the build tags of the generated mocks. Read more about the format. <code>skip-ensure</code> <code>bool</code> Suppress mock implementation check, avoid import cycle if mocks generated outside of the tested package. <code>stub-impl</code> <code>bool</code> Return zero values when no mock implementation is provided, do not panic. <code>with-resets</code> <code>bool</code> Generates methods that allow resetting calls made to the mocks."},{"location":"templates/","title":"Templates","text":"<p>Mockery, in its essence, renders templates. This project provides a number of pre-curated templates that you can select with the <code>template:</code> config parameter.</p>"},{"location":"templates/#template-options","title":"Template Options","text":""},{"location":"templates/#template-mockery","title":"<code>template: \"mockery\"</code>","text":"<p><code>mockery</code> templates generate powerful, testify-based mock objects. They allow you to create expectations using argument-to-return-value matching logic.</p> Go<pre><code>package test\n\nimport (\n    \"testing\"\n\n    \"github.com/stretchr/testify/assert\"\n)\n\nfunc TestRequesterMock(t *testing.T) {\n    m := NewMockRequester(t)\n    m.EXPECT().Get(\"foo\").Return(\"bar\", nil).Once()\n    retString, err := m.Get(\"foo\")\n    assert.NoError(t, err)\n    assert.Equal(t, retString, \"bar\")\n}\n</code></pre>"},{"location":"templates/#template-moq","title":"<code>template: \"moq\"</code>","text":"<p><code>moq</code> templates draw from the mocks generated from the project at https://github.com/matryer/moq. This project was folded into mockery, and thus moq-style mocks can be natively generated from within mockery.</p> <p>Mocks generated using this template allow you to define precise functions to be run. Example:</p> Go<pre><code>func TestRequesterMoq(t *testing.T) {\n    m := &amp;MoqRequester{\n        GetFunc: func(path string) (string, error) {\n            fmt.Printf(\"Go path: %s\\n\", path)\n            return path + \"/foo\", nil\n        },\n    }\n    result, err := m.Get(\"/path\")\n    assert.NoError(t, err)\n    assert.Equal(t, \"/path/foo\", result)\n}\n</code></pre>"},{"location":"templates/#template-file","title":"<code>template: \"file://</code>","text":"<p>You may also provide mockery a path to your own file using the <code>file://</code> protocol specifier. The string after <code>file://</code> will be the relative or absolute path of your template.</p> <p>The templates are rendered with the data as shown in the section below.</p> <p>You can see examples of how the mockery project utilizes the template system to generate the different mock styles:</p> <ul> <li><code>moq.templ</code></li> <li><code>mockery.templ</code></li> </ul>"},{"location":"templates/#data-provided-to-templates","title":"Data Provided To Templates","text":"<p>Mockery has two separate template instances: one for the <code>.mockery.yml</code> file, and one for the mock templates. Each instance has a different set of variables and functions available to it. All functions are pipeline-compatible.</p>"},{"location":"templates/#mockeryyml","title":"<code>.mockery.yml</code>","text":"<p>As seen in the configuration section, mockery configuration has template variables and methods available to it.</p>"},{"location":"templates/#functions","title":"Functions","text":"<p>Functions provided are in the <code>StringManipulationFuncs</code> variable.</p>"},{"location":"templates/#variables","title":"Variables","text":"<p>The variables available are defined in the <code>template.ConfigData</code> struct.</p>"},{"location":"templates/#template-files","title":"Template Files","text":""},{"location":"templates/#functions_1","title":"Functions","text":"<p>Template files have both <code>StringManipulationFuncs</code> and <code>TemplateMockFuncs</code> available as functions.</p>"},{"location":"templates/#variables_1","title":"Variables","text":"<p>The template is supplied with the <code>template.Data</code> struct. Some attributes return types such as <code>template.MockData</code> and <code>template.Package</code> which themselves contain methods that may also be called.</p>"},{"location":"v3/","title":"v3 Release","text":"<p>Mockery releases version 3 of the project that provides a number of high-profile benefits over v2:</p> <ol> <li>Allows generation of <code>moq</code>-style templates. The https://github.com/matryer/moq project is being folded into mockery to combine the speed and configuration flexibility of mockery with the simplicity of moq-style mocks.</li> <li>Changes the generation scheme to be entirely driven off of Go templates. This means that the data provided to templates is considered as part of the public API.</li> <li>Mockery now allows users to specify their own templates to make code generation far easier. Mockery handles the problem of parsing source code and enables you to focus on creating your own interface implementations.</li> <li>Shedding all deprecated variables and simplifying the way in which mocks are configured.</li> </ol>"},{"location":"v3/#v2-migration","title":"v2 Migration","text":"<p>Construction</p> <p>This section is under construction.</p>"}]}